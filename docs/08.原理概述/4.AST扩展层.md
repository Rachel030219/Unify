# AST扩展层

由于 Flutter Channel 不支持传输自定义类型数据。`AST扩展层`允许将自定义类型数据，当作协议接口的参数，直接进行跨端传输。它主要提供：

* 发送场景：自动检测数据类型中的所有子元素，将`自定义类型`的数据 Json 化。
* 接收场景：自动转换接收到的数据，将 Json 化的数据映射成`自定义类型`数据。

最终实现：“你只管`Send / Receive`，背后转换让 Unify 自动处理”。

背后的核心逻辑，参考下面的`对象 -> Json 格式`和`Json 格式 -> 对象`。

### 对象 -> Json 格式
这部分内容主要是描述`实例对象`到`Json`格式类型的转换过程。
<img src="../public/009.png" width="600"/>

> `listClone` 和 `mapClone`这块使用了递归思想。主要实现`List`或`Map`中的实例对象都转换成`Json`格式的数据。

### Json 格式 -> 对象
这部分内容主要是描述`Json`格式类型到`实例对象`的转换过程。
<img src="../public/010.png" width="600"/>

> `listConvert` 和 `mapConvert`这块使用了递归思想。主要实现`List`或`Map`中的`Json`格式的数据都还原成原有类型的实例对象。
>> 映射表参见下面的`映射表说明`。

#### 映射表说明
什么是映射表？主要存储了泛型参数，其本质是数据的类型，比如下面的泛型定义:

`List<Map<String, List<GenericityModel?>?>?>`

经过 Unify 处理后，可以获得下面的映射表: 

`[AstList, AstMap, AstList, AstCustomType]`。

> 为什么产生一个映射表？我们想要将 `Json` 格式的数据还原成`entity`的`真身`类型，就需要知道这个`entity`被定义时的`真身`是什么类型。
>> 注意：这块和上面的`对象 → Json 格式`的转换是有区别的。
>
> 这个映射表就是查询`真身`类型用的。